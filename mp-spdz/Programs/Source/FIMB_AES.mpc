from circuit import Circuit

def biginteger_to_hex(n):
    # Determine the number of hex digits expected in the output
    expected_hex_digits = 32  # This is inferred from the example output length
    bit_length = expected_hex_digits * 4  # Each hex digit represents 4 bits

    if n < 0:
        # Compute two's complement manually
        two_complement = (1 << bit_length) + n
        
        # Convert to hexadecimal
        hex_value = hex(two_complement)
    else:
        # Direct conversion for positive numbers
        hex_value = hex(n)
    
    # Format the hex value to remove the '0x' prefix and pad if necessary
    formatted_hex = hex_value[2:].lower().zfill(expected_hex_digits)
    
    return formatted_hex


sb128 = sbits.get_type(128)


n = int(1)


IV_c = Array(10, sb128)
IV_mb = Array(10, sb128)
IV_c.length = public_input()
print_ln("Size of IV_c: %s", IV_c.length)

@for_range(IV_c.length)
def _(i):
    IV_c[i] = sb128.get_input_from(0)
    IV_mb[i] = sb128.get_input_from(1)
    print_ln("Reading lines.... ")


def eq_check(IV_c, IV_mb):
    test_result = MemValue(1)
    @for_range(IV_c.length)
    def _(i):
        @if_e (IV_c[i].equal(IV_mb[i]).reveal())
        def _():
            print_ln("true match")
        @else_
        def _():
            print_ln("false match")
            test_result.write(0)
    return test_result.reveal()

a = eq_check(IV_c, IV_mb)
print_ln("Final checking result:%s", a)

@if_e (a == 1)
def _():
    Key = sb128.get_input_from(0)
    aes128 = Circuit('aes_128')
    @for_range(IV_c.length)
    def _(i):
        e = aes128(sbitvec([Key]), sbitvec([IV_mb[i]]))
        result = e.elements()[0].reveal()
        print_ln("The key stream for %s: %s", i+1, result)
@else_
def _():
    print_ln('Detected MB input error')
